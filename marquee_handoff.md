Marquee Selection + Connector/Mindmap Handoff

  - Transformers now route through TransformLifecycleCoordinator with snapshots generated by TransformController, but connectors still refuse to move during marquee drags. Snapshot capture
  can’t reliably find the Konva groups emitted by ConnectorRenderer, so connectors stays at 0. Meanwhile mindmap branches rely on store snapshots that never update during drag, so they only
  reroute at drag end.
  - Manual QA (screenshots Screenshot from 2025-09-29 14-21-13.png, 14-21-20.png) shows marquee picks up connectors but they remain stationary and the transformer disappears on release.
  Mindmap branches stretch then snap back.
  - Docs updated: docs/architecture/canvas-implementation-progress.md and docs/known-issues.md both flag marquee remains broken and describe next steps.

  Investigations / Findings

  - ConnectorRenderer creates shapes but they’re not discoverable via stage.findOne(#id); we may need it to set group.id(conn.id) or at least a consistent elementId on a parent Konva.Group.
  - Even with point fallbacks, connectors don’t move because we’re not translating the shape/group itself during drag. Without a real node handle the snapshot can’t update visuals.
  - Mindmap edges are data-driven. During drag we need to update store positions (e.g. updateElement(id, { x: base.x + dx, y: base.y + dy })) or adapt MindmapRenderer to consume live Konva
  positions.

  Next Steps

  1. Adjust ConnectorRenderer to expose a stable Konva group (id or elementId) so captureTransformSnapshot can pull connectors into snapshot.connectors.
  2. In progressSelectionTransform, once connectors appear in the snapshot, translate the Konva group/line (existing controller logic supports this) and continue rerouting for anchored
  endpoints.
  3. Update mindmap nodes during drag (store updates or renderer integration) so MindmapController receives fresh positions and branches follow the marquee live.
  4. Optionally pause mindmap live routing during drag to avoid rollback from concurrent reroutes.
  5. Re-test marquee with mixed sticky + connector + mindmap selections; expect Transform snapshot logs to show connectors > 0 and connectors to move along with the group.

  Recent Commits

  - Refactor selection controllers and expand marquee debug
  - Document marquee selection investigation status

  Please coordinate with whatever change you make in ConnectorRenderer or MindmapRenderer to ensure store-driven architecture stays intact, and update docs again once marquee + connectors
  behave correctly.
  
  Root Cause

During marquee-drag moves, the canvas’s transform snapshot mechanism isn’t capturing connectors or mindmap edges. The SelectionModule.captureTransformSnapshot only runs when shapes are moved via the Konva Transformer (or programmatic transform); marquee dragging (which uses raw drag events and store actions) doesn’t invoke that snapshot logic. Consequently, connectors aren’t recorded with their geometry, and mindmap branches (which rely on live rerouting) remain static until the drag ends. In practice, connectors “bypass” the transformer (Konva docs confirm line/arrow shapes won’t move with a Transformer
GitHub
), so they never get included in the snapshot unless explicitly handled. Indeed, captureTransformSnapshot() looks up each connector’s Konva Group by id and then its shape via .connector-shape
GitHub
; if the group ID isn’t set or the snapshot isn’t run, the connector is skipped. Similarly, for mindmap nodes the snapshot logic sets pauseLiveRouting=true (see below) and only re-routes edges at drag end, so branches appear frozen during the drag. In short, connectors were never part of the live transform (and lacked explicit IDs in some renderers), and mindmap live-routing was disabled during the move, so their edges did not follow the drag in real-time.

Solutions

To fix this, we must both include connectors in the scene graph and update edges continuously during marquee drags:

Render connectors with a Konva Group ID. The connector renderer must set group.id = connector.id (and/or elementId) so snapshots can find it. In our code, the ConnectorRenderer already does this: it creates a Konva group with id: conn.id and name: "connector"
GitHub
. Ensuring this is always done (and calling it a transformer-ignored type with nodeType='connector') guarantees the snapshot builder’s stage.findOne(#${connectorId}) will succeed. If a renderer missed setting the group ID, connectors would be invisible to the snapshot logic
GitHub
.

Apply the drag delta to connector shapes during the move. In the marquee tool’s “progressTransform” handler, we must translate connectors by the same (dx,dy) as the selected elements. One approach is to mirror the applyConnectorTranslation() logic from the SelectionModule. For each connector in the snapshot, compute new endpoints by adding the drag delta (as startFrom+dx, startTo+dy) and update the Konva shapes or the store. For example, the code does:

const nextFrom = {x: startFrom.x + dx, y: startFrom.y + dy, kind: "point"};
const nextTo   = {x: startTo.x + dx,   y: startTo.y + dy,   kind: "point"};
this.updateConnectorElement(id, { from: nextFrom, to: nextTo });


This moves the connector’s endpoints on screen. In practice, we can either update the store (as above, with pushHistory: false for a live update) or directly adjust the Konva group (e.g. group.position({ x: originalX+dx, y: originalY+dy })) and let Konva redraw. The key is that on every drag frame we offset the connector geometry by the same delta.

Update mindmap branches live during drag. The mindmap renderer must likewise move nodes and reroute edges on-the-fly. One method is to update the store positions of selected mindmap nodes by the drag delta (so that when the renderer re-renders, edges update accordingly). Another is to directly call the renderer to redraw connected edges each frame. For example, the MindmapRenderer’s drag handlers show this pattern: on node-drag, it calls updateConnectedEdgesForNode() and redraws
GitHub
. In our marquee transform, we should similarly call mindmapRenderer.updateConnectedEdges(nodeId) (for each moved node) or batch-reroute via batchMindmapReroute(renderer, movedMindmapNodes). This ensures the tapered-branch shapes update at each step. If we update the node groups’ x,y positions as part of the transform, calling the renderer’s edge-update logic will redraw the branches in the new positions continuously.

Control live routing (pause vs. resume) appropriately. By default, the snapshot logic disables live routing during a transform (see if (movedMindmapNodes.size>0) this.setMindmapLiveRoutingEnabled(false);
GitHub
). This was intended to avoid intermediate rerouting glitches. However, if we’re manually applying all deltas each frame, we can choose to keep live routing off (so edges only follow our manual updates), or briefly re-enable it to allow the renderer to auto-update. To avoid “rollback” artifacts, it may be simpler to keep live routing paused and handle all updates explicitly. In practice, with manual edge updates on each progressTransform, no rollback occurs. If we do resume live routing mid-drag, be sure to recapture or re-project base positions to prevent the renderer from snapping edges back on drag cancel. In summary: either maintain the pauseLiveRouting during the drag (as currently coded) or disable it only after repositioning nodes – the important part is that live-edge rerouting happens in sync with the drag, not just at the end.

Preserve the transformer’s attachment box on drag-end. (Optional fix.) Sometimes when multiple elements are dragged together, the Konva Transformer box can detach or flicker. To prevent this, we should reattach the transformer after the drag. In SelectionModule.onTransformEnd, we already detach then re-attach the transformer to the moved nodes
GitHub
. Ensure a similar re-attachment happens for marquee drags: after the drag ends and we have applied final positions, call transformerManager.attachToNodes([...]) on the selected nodes so the blue selection box doesn’t “drop out.” This restores the transformer’s frame around the moved elements.

Architectural notes: These fixes assume the store’s selection and element slices allow updating connector and mindmap-element positions during an ongoing transform (with pushHistory: false for live moves). The renderer modules (ConnectorRenderer, MindmapRenderer) should already respect Konva node IDs and attributes. For example, connectors have group.id = connector.id and shapes named "connector-shape"
GitHub
GitHub
, and mindmap nodes use group.id = node.id (see nodeGroups in MindmapRenderer) so transforms apply correctly. By extending the SelectionModule (or MarqueeSelectionTool) to perform these live updates, connectors and mindmap branches will visibly move with the drag instead of snapping back at the end
GitHub
GitHub
.

Sources: The above is informed by the architecture notes and code: connector shapes are rendered in a group with id=connector.id
GitHub
, and the selection snapshot logic finds those groups by id
GitHub
. The known-issues document notes that connectors “remain transformer-free” and require manual rerouting during marquee moves
GitHub
, which is solved by enabling per-frame updates. Mindmap rerouting is currently paused in captureTransformSnapshot
GitHub
 and only done after transformEnd; we must alter this to update during progressSelectionTransform (or equivalent marquee drag progress). These changes ensure the live UI matches the underlying state throughout the drag.